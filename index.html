<!DOCTYPE html>
<html>
<head>
    <title>WebGL Shader with Recording</title>
    <style>
        body { margin: 0; }
        canvas { display: block; width: 100%; height: 100%; }
        form {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 50%;
            min-width: 500px;
            background-color: white;
            border: 1px solid black;
            padding: 20px;
            font-family: sans-serif;
            font-size: 18px;
        }
        label {
            display: block;
            margin-bottom: 4px;
        }
        input {
            margin-bottom: 15px;
        }
        textarea {
            font-size: 16px;
            width: 100%;
        }
        em {
            display: block;
            color: #555;
            font-size: 15px;
            margin-bottom: 15px;
        }
        .color-input {
            width: 100px;
            height: 30px;
        }
        .recording-controls {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #ccc;
        }
        .recording-controls button {
            padding: 10px 20px;
            margin-right: 10px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }
        .recording-controls button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .recording-controls button.stop {
            background-color: #f44336;
        }
        .recording-status {
            color: #f44336;
            font-weight: bold;
            margin-top: 10px;
            display: none;
        }
        #downloadLink {
            display: none;
            margin-top: 10px;
            padding: 10px;
            background-color: #2196F3;
            color: white;
            text-decoration: none;
            border-radius: 4px;
            font-size: 16px;
        }
        .recording-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            background-color: #f44336;
            color: white;
            border-radius: 4px;
            display: none;
        }
        .recording-indicator.active {
            display: block;
        }
    </style>
</head>
<body>
<canvas id="glcanvas"></canvas>
<div id="recordingIndicator" class="recording-indicator">Recording...</div>
<form id="shaderForm">
    <label>Effect source:</label>
    <textarea id="effectSource" rows="4" cols="50">vec2 effect(vec2 p, float i, float time) {
    return vec2(sin(p.x * i + time) * cos(p.y * i + time), sin(length(p.x)) * cos(length(p.y)));
}</textarea>
    <em>Try the <a target="_blank" href="https://replicate.com/andreasjansson/plasma">generator</a></em>
    
    <label>Color 1:</label>
    <input type="color" id="color1" class="color-input" value="#EBE75C"><br>
    
    <label>Color 2:</label>
    <input type="color" id="color2" class="color-input" value="#DF4843"><br>
    
    <label>Color 3:</label>
    <input type="color" id="color3" class="color-input" value="#EB40F0"><br>
    
    <label>Speed:</label>
    <input type="number" id="speed" value="0.2" step="0.01"><br>
    
    <label>Resolution:</label>
    <input type="number" id="resolution" value="4.0" step="0.1"><br>
    
    <label>Recursion depth:</label>
    <input type="number" id="depth" value="5" step="1" min="1" max="200"><br>
    
    <input type="submit" value="Update shader">

    <div class="recording-controls">
        <button id="startRecording" type="button">Start Recording</button>
        <button id="stopRecording" type="button" class="stop" disabled>Stop Recording</button>
        <a id="downloadLink" download="shader-recording.webm">Download Recording</a>
    </div>
</form>

<script type="text/javascript">
    var canvas = document.getElementById('glcanvas');
    var gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

    if (!gl) {
        alert('Unable to initialize WebGL. Your browser may not support it.');
        throw 'Unable to initialize WebGL';
    }

    let mediaRecorder = null;
    let recordedChunks = [];
    const startRecordingBtn = document.getElementById('startRecording');
    const stopRecordingBtn = document.getElementById('stopRecording');
    const downloadLink = document.getElementById('downloadLink');
    const recordingIndicator = document.getElementById('recordingIndicator');

    if (!navigator.mediaDevices && !navigator.mediaDevices.getUserMedia) {
        console.warn('Recording features are not supported in this browser');
        startRecordingBtn.disabled = true;
        startRecordingBtn.title = 'Recording not supported in this browser';
    }

    function hexToRGB(hex) {
        const r = parseInt(hex.slice(1, 3), 16) / 255;
        const g = parseInt(hex.slice(3, 5), 16) / 255;
        const b = parseInt(hex.slice(5, 7), 16) / 255;
        return [r, g, b];
    }

    var vertexShaderSource = `
        attribute vec2 position;
        void main() {
            gl_Position = vec4(position, 0.0, 1.0);
        }
    `;

    var shaderProgram, positionLocation, iResolutionLocation, iTimeLocation;
    var color1Location, color2Location, color3Location;
    var positionBuffer = gl.createBuffer();

    function resizeCanvasToDisplaySize() {
        const width = window.innerWidth;
        const height = window.innerHeight;
        if (canvas.width !== width || canvas.height !== height) {
            canvas.width = width;
            canvas.height = height;
            gl.viewport(0, 0, width, height);
            return true;
        }
        gl.viewport(0, 0, width, height);
        return true;
    }

    function getFragmentShaderSource(effectSource, speed, resolution, depth) {
        return `
            precision mediump float;
            uniform vec2 iResolution;
            uniform float iTime;
            uniform vec3 color1;
            uniform vec3 color2;
            uniform vec3 color3;

            ${effectSource}

            void main() {
                vec2 p = (2.0 * gl_FragCoord.xy - iResolution.xy) / max(iResolution.x, iResolution.y);
                p *= float(${resolution});
                for (int i = 1; i < ${depth}; i++) {
                    float fi = float(i);
                    p += effect(p, fi, iTime * float(${speed}));
                }
                vec3 col = mix(mix(color1, color2, 1.0-sin(p.x)), color3, cos(p.y+p.x));
                gl_FragColor = vec4(col, 1.0);
            }
        `;
    }

    function createShaderProgram(effectSource, speed, resolution, depth) {
        var vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, vertexShaderSource);
        gl.compileShader(vertexShader);

        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        var fragmentShaderSource = getFragmentShaderSource(effectSource, speed, resolution, depth);
        gl.shaderSource(fragmentShader, fragmentShaderSource);
        gl.compileShader(fragmentShader);

        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
            alert('Fragment shader compilation error: ' + gl.getShaderInfoLog(fragmentShader));
            return;
        }

        if (shaderProgram) {
            gl.deleteProgram(shaderProgram);
        }

        shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
            return;
        }

        gl.useProgram(shaderProgram);

        positionLocation = gl.getAttribLocation(shaderProgram, 'position');
        iResolutionLocation = gl.getUniformLocation(shaderProgram, 'iResolution');
        iTimeLocation = gl.getUniformLocation(shaderProgram, 'iTime');
        color1Location = gl.getUniformLocation(shaderProgram, 'color1');
        color2Location = gl.getUniformLocation(shaderProgram, 'color2');
        color3Location = gl.getUniformLocation(shaderProgram, 'color3');

        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        var positions = [
            -1.0, -1.0, 1.0, -1.0, -1.0,  1.0,
            -1.0,  1.0, 1.0, -1.0,  1.0,  1.0
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(positionLocation);

        const color1 = hexToRGB(document.getElementById('color1').value);
        const color2 = hexToRGB(document.getElementById('color2').value);
        const color3 = hexToRGB(document.getElementById('color3').value);
        
        gl.uniform3f(color1Location, color1[0], color1[1], color1[2]);
        gl.uniform3f(color2Location, color2[0], color2[1], color2[2]);
        gl.uniform3f(color3Location, color3[0], color3[1], color3[2]);

        resizeCanvasToDisplaySize();
    }

    function render(time) {
        if (resizeCanvasToDisplaySize()) {
            gl.uniform2f(iResolutionLocation, gl.canvas.width, gl.canvas.height);
        }

        gl.uniform1f(iTimeLocation, time * 0.001);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
        requestAnimationFrame(render);
    }

    function update(event) {
        if (event) event.preventDefault();
        createShaderProgram(
            document.getElementById('effectSource').value,
            document.getElementById('speed').value,
            document.getElementById('resolution').value,
            document.getElementById('depth').value
        );
    }

    function startRecording() {
        recordedChunks = [];
        const stream = canvas.captureStream(30); // 30 FPS

        const mimeTypes = [
            'video/webm;codecs=vp9',
            'video/webm;codecs=vp8',
            'video/webm'
        ];
        
        let selectedMimeType = null;
        for (const mimeType of mimeTypes) {
            if (MediaRecorder.isTypeSupported(mimeType)) {
                selectedMimeType = mimeType;
                break;
            }
        }

        if (!selectedMimeType) {
            alert('No supported recording MIME type found');
            return;
        }

        const options = {
            mimeType: selectedMimeType,
            videoBitsPerSecond: 2500000 // 2.5 Mbps
        };

        try {
            mediaRecorder = new MediaRecorder(stream, options);
        } catch (e) {
            alert('Error creating MediaRecorder: ' + e);
            return;
        }

        mediaRecorder.ondataavailable = (event) => {
            if (event.data && event.data.size > 0) {
                recordedChunks.push(event.data);
            }
        };

        mediaRecorder.onstop = () => {
            const blob = new Blob(recordedChunks, { type: selectedMimeType });
            downloadLink.href = URL.createObjectURL(blob);
            downloadLink.style.display = 'inline-block';
            recordingIndicator.classList.remove('active');
        };

        mediaRecorder.start(100); // Collect data every 100ms
        startRecordingBtn.disabled = true;
        stopRecordingBtn.disabled = false;
        downloadLink.style.display = 'none';
        recordingIndicator.classList.add('active');
    }

    function stopRecording() {
        if (mediaRecorder && mediaRecorder.state !== 'inactive') {
            mediaRecorder.stop();
            startRecordingBtn.disabled = false;
            stopRecordingBtn.disabled = true;
        }
    }

    // Event listeners
    document.getElementById('speed').addEventListener('change', update);
    document.getElementById('resolution').addEventListener('change', update);
    document.getElementById('depth').addEventListener('change', update);
    document.getElementById('color1').addEventListener('change', update);
    document.getElementById('color2').addEventListener('change', update);
    document.getElementById('color3').addEventListener('change', update);
    document.getElementById('shaderForm').addEventListener('submit', update);
    startRecordingBtn.addEventListener('click', startRecording);
    stopRecordingBtn.addEventListener('click', stopRecording);

    window.addEventListener('beforeunload', () => {
        if (mediaRecorder && mediaRecorder.state === 'recording') {
            mediaRecorder.stop();
        }
    });

    // Initial setup
    createShaderProgram(
        document.getElementById('effectSource').value,
        document.getElementById('speed').value,
        document.getElementById('resolution').value,
        document.getElementById('depth').value
    );
    requestAnimationFrame(render);
</script>
</body>
</html>
