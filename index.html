<!DOCTYPE html>
>
<head>
    <title>WebGL Shader</title>
    <style>
        body { margin: 0; }
        canvas { display: block; width: 100%; height: 100%; }
        form {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 50%;
            min-width: 500px;
            background-color: white;
            border: 1px solid black;
            padding: 20px;
            font-family: sans-serif;
            font-size: 18px;
        }
        label {
            display: block;
            margin-bottom: 4px;
        }
        input {
            margin-bottom: 15px;
        }
        textarea {
            font-size: 16px;
            width: 100%;
        }
        em {
            display: block;
            color: #555;
            font-size: 15px;
            margin-bottom: 15px;
        }
        .color-input {
            width: 100px;
            height: 30px;
        }
        #recordButton {
            background-color: #ff4444;
            color: white;
            border: none;
            padding: 10px 20px;
            cursor: pointer;
            margin-top: 10px;
        }
        #recordButton.recording {
            background-color: #444;
        }
    </style>
>
<canvas id="glcanvas"></canvas>
<form id="shaderForm">
    <label>Effect source:</label>
    <textarea id="effectSource" rows="4" cols="50">vec2 effect(vec2 p, float i, float time) {
    return vec2(sin(p.x * i + time) * cos(p.y * i + time), sin(length(p.x)) * cos(length(p.y)));
}</textarea>
    <em>Try the <a target="_blank" href="https://replicate.com/andreasjansson/plasma">generator</a>
    <label>Color 1:</label>
    <input type="color" id="color1" class="color-input" value="#EBE75C"><br>
    
    <label>Color 2:</label>
    <input type="color" id="color2" class="color-input" value="#DF4843"><br>
    
    <label>Color 3:</label>
    <input type="color" id="color3" class="color-input" value="#EB40F0"><br>
    
    Speed:</label>
    <input type="number" id="speed" value="0.2" step="0.01"><br>
    
    <label>Resolution:</label>
    <input type="number" id="resolution" value="4.0" step="0.1"><br>
    
    Recursion depth:</label>
    <input type="number" id="depth" value="5" step="1" min="1" max="200"><br>
    
    <input type="submit" value="Update shader">
    <button type="button" id="recordButton">Start Recording</button>
</form>
<script type="text/javascript">
    var canvas = document.getElementById('glcanvas');
    var gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    var mediaRecorder;
    var recordedChunks = [];
    var isRecording = false;

    if (!gl) {
        alert('Unable to initialize WebGL. Your browser may not support it.');
        throw 'Unable to initialize WebGL';
    }

    function hexToRGB(hex) {
        const r = parseInt(hex.slice(1, 3), 16) / 255;
        const g = parseInt(hex.slice(3, 5), 16) / 255;
        const b = parseInt(hex.slice(5, 7), 16) / 255;
        return [r, g, b];
    }

    var vertexShaderSource = `
        attribute vec2 position;
        void main() {
            gl_Position = vec4(position, 0.0, 1.0);
        }
    `;

    var shaderProgram, positionLocation, iResolutionLocation, iTimeLocation;
    var color1Location, color2Location, color3Location;
    var positionBuffer = gl.createBuffer();

    function resizeCanvasToDisplaySize() {
        const width = window.innerWidth;
        const height = window.innerHeight;
        if (canvas.width !== width || canvas.height !== height) {
            canvas.width = width;
            canvas.height = height;
            gl.viewport(0, 0, width, height);
            return true;
        }
        gl.viewport(0, 0, width, height);
        return true;
    }

    function getFragmentShaderSource(effectSource, speed, resolution, depth) {
        return `
            precision mediump float;
            uniform vec2 iResolution;
            uniform float iTime;
            uniform vec3 color1;
            uniform vec3 color2;
            uniform vec3 color3;

            ${effectSource}

            void main() {
                vec2 p = (2.0 * gl_FragCoord.xy - iResolution.xy) / max(iResolution.x, iResolution.y);
                p *= float(${resolution});
                for (int i = 1; i < ${depth}; i++) {
                    float fi = float(i);
                    p += effect(p, fi, iTime * float(${speed}));
                }
                vec3 col = mix(mix(color1, color2, 1.0-sin(p.x)), color3, cos(p.y+p.x));
                gl_FragColor = vec4(col, 1.0);
            }
        `;
    }

    function createShaderProgram(effectSource, speed, resolution, depth) {
        var vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, vertexShaderSource);
        gl.compileShader(vertexShader);

        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        var fragmentShaderSource = getFragmentShaderSource(effectSource, speed, resolution, depth);
        gl.shaderSource(fragmentShader, fragmentShaderSource);
        gl.compileShader(fragmentShader);

        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
            alert('Fragment shader compilation error: ' + gl.getShaderInfoLog(fragmentShader));
            return;
        }

        if (shaderProgram) {
            gl.deleteProgram(shaderProgram);
        }

        shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
            return;
        }

        gl.useProgram(shaderProgram);

        positionLocation = gl.getAttribLocation(shaderProgram, 'position');
        iResolutionLocation = gl.getUniformLocation(shaderProgram, 'iResolution');
        iTimeLocation = gl.getUniformLocation(shaderProgram, 'iTime');
        color1Location = gl.getUniformLocation(shaderProgram, 'color1');
        color2Location = gl.getUniformLocation(shaderProgram, 'color2');
        color3Location = gl.getUniformLocation(shaderProgram, 'color3');

        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        var positions = [
            -1.0, -1.0, 1.0, -1.0, -1.0,  1.0,
            -1.0,  1.0, 1.0, -1.0,  1.0,  1.0
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(positionLocation);

        const color1 = hexToRGB(document.getElementById('color1').value);
        const color2 = hexToRGB(document.getElementById('color2').value);
        const color3 = hexToRGB(document.getElementById('color3').value);
        
        gl.uniform3f(color1Location, color1[0], color1[1], color1[2]);
        gl.uniform3f(color2Location, color2[0], color2[1], color2[2]);
        gl.uniform3f(color3Location, color3[0], color3[1], color3[2]);

        resizeCanvasToDisplaySize();
    }

    function render(time) {
        if (resizeCanvasToDisplaySize()) {
            gl.uniform2f(iResolutionLocation, gl.canvas.width, gl.canvas.height);
        }

        gl.uniform1f(iTimeLocation, time * 0.001);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
        requestAnimationFrame(render);
    }

    function update(event) {
        if (event) event.preventDefault();
        createShaderProgram(
            document.getElementById('effectSource').value,
            document.getElementById('speed').value,
            document.getElementById('resolution').value,
            document.getElementById('depth').value
        );
    }

    // Recording functionality
    function startRecording() {
        recordedChunks = [];
        const stream = canvas.captureStream(60);
        mediaRecorder = new MediaRecorder(stream, {
            mimeType: 'video/webm;codecs=vp9'
        });

        mediaRecorder.ondataavailable = (event) => {
            if (event.data.size > 0) {
                recordedChunks.push(event.data);
            }
        };

        mediaRecorder.onstop = () => {
            const blob = new Blob(recordedChunks, {
                type: 'video/webm'
            });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'shader-recording.webm';
            a.click();
            URL.revokeObjectURL(url);
        };

        mediaRecorder.start();
        isRecording = true;
        recordButton.textContent = 'Stop Recording';
        recordButton.classList.add('recording');
    }

    function stopRecording() {
        mediaRecorder.stop();
        isRecording = false;
        recordButton.textContent = 'Start Recording';
        recordButton.classList.remove('recording');
    }

    const recordButton = document.getElementById('recordButton');
    recordButton.addEventListener('click', () => {
        if (!isRecording) {
            startRecording();
        } else {
            stopRecording();
        }
    });

    // Add event listeners
    document.getElementById('speed').addEventListener('change', update);
    document.getElementById('resolution').addEventListener('change', update);
    document.getElementById('depth').addEventListener('change', update);
    document.getElementById('color1').addEventListener('change', update);
    document.getElementById('color2').addEventListener('change', update);
    document.getElementById('color3').addEventListener('change', update);
    document.getElementById('shaderForm').addEventListener('submit', update);

    // Initial setup
    createShaderProgram(
        document.getElementById('effectSource').value,
        document.getElementById('speed').value,
        document.getElementById('resolution').value,
        document.getElementById('depth').value
    );
    requestAnimationFrame(render);
</script>
html>
